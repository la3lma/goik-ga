\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, bm}
\usepackage[hidelinks]{hyperref}
\usepackage{geometry}
\geometry{margin=1in}

\title{Hexapod Kinematics with Geometric Algebra: A Practical Refactor}
\author{Prepared for Bj\o rn Remseth}
\date{\today}

\begin{document}
\maketitle

\noindent\textbf{Acknowledgment:} This work is strongly inspired by and builds upon the excellent foundation provided by Hans JÃ¸rgen Grimstad's \texttt{goik} package~\footnote{\url{https://github.com/hansj66/goik/tree/main/goik}}, which pioneered practical hexapod kinematics implementations in Go.

\section{Why Geometric Algebra (GA)?}
Hexapod math based on per-joint rotation matrices and translations quickly accumulates frame bookkeeping.
\emph{Projective Geometric Algebra} (PGA) and \emph{Conformal Geometric Algebra} (CGA)~\cite{dorst2009gacs} provide unified representations (motors/rotors) that act by a single sandwich product, reducing complexity and improving robustness.

\paragraph{PGA for SE(3).}
Rigid motions (rotations + translations) are represented by \emph{motors}~\cite{gunn2011pga}, which you can view as the geometric-algebraic analog of dual quaternions. Composition is associative; points are updated via $X' = M X \tilde{M}$.

\paragraph{CGA for incidence/distance.}
CGA encodes points as null vectors and treats planes, lines, circles, and spheres as native objects~\cite{dorst2009gacs}. Translations are rotors in CGA, and meet/join operations give concise formulas for projections, distances, and constraints.

\section{Representations}
\subsection{PGA (practical)}
We implement motors as dual quaternions $(r + \varepsilon d)$ with unit $r$~\cite{kavan2008dq}.
Given axis-angle $(\mathbf{\hat{u}}, \theta)$ and translation $\mathbf{t}$:
\[
r = \cos \tfrac{\theta}{2} + \sin \tfrac{\theta}{2} \, (\hat{u}_x \mathbf{i} + \hat{u}_y \mathbf{j} + \hat{u}_z \mathbf{k}),\quad
d = \tfrac{1}{2} \, \mathbf{t}\, r.
\]
Composition is $(r_1, d_1)(r_2, d_2) = (r_1 r_2,\; r_1 d_2 + d_1 r_2)$.
A point $\mathbf{p}$ transforms as
\[
\mathbf{p}' = r\,\mathbf{p}\,r^* + 2\,\mathrm{vec}(d\,r^*).
\]
This matches PGA motor action for SE(3).

\subsection{CGA (parallel sketch)}
CGA lifts $\mathbb{R}^3$ into a 5D space with two null directions $e_0, e_\infty$~\cite{dorst2009gacs}.
Points, planes, spheres, and circles become algebraic blades. Rotors (including translations) act by $X' = R X \tilde{R}$.
We provide an API mirroring the PGA motor API; the current code routes to the PGA backend so you can wire usage now and swap later.

\section{Forward and Inverse Kinematics}
\paragraph{Forward Kinematics (FK).}
Define per-joint screw motions as motors and compose:
\[
P_{\text{toe}} = M_B\, M_{\text{hip}}\, R_1\, M_{\text{thigh}}\, R_2\, M_{\text{knee}}\, R_3\, P_0\, \widetilde{(\cdot)}.
\]
Our Go code builds these via \verb|Screw| and \verb|Translator|.

\paragraph{Analytic IK (per leg).}
Use line/point relations to recover joint angles: for a hip yaw, take the angle between the hip axis and the projected toe direction; for the planar thigh-knee pair, use cosine law on the triangle defined by link lengths and the hip$\rightarrow$toe distance.

\paragraph{Numerical IK.}
Build Jacobian columns from twists. For a revolute joint about axis $(\mathbf{c}, \hat{\mathbf{u}})$, the instantaneous linear velocity of a point is $ \hat{\mathbf{u}} \times (\mathbf{p} - \mathbf{c})$. Stack columns and solve $\Delta \theta = J^\dagger (\mathbf{x}^* - \mathbf{x})$ with damping.

\section{Contact and Constraints}
With CGA, the ground plane $\Pi$ and toe point $P$ satisfy $\Pi \wedge P = 0$ at contact.
Projection is a meet/join expression. In the current package, you can emulate with vector math or upgrade the \verb|cga| package later.

\section{Migration Notes}
Replace sequences of rotation matrices + translations with motors.
Precompute static offsets as motors. FK becomes a product; IK uses either the analytic triangle plus axis-angle recovery or a Jacobian solver.

\section{Complexity and Robustness}
GA reduces trig and frame conversions, unifies operations, and offers a clear path to autodiff and MPC~\cite{lasenby2024ga}. Dual-quaternion motors are numerically stable and cheap to normalize.

\bibliographystyle{ieeetr}
\bibliography{refs}
\end{document}

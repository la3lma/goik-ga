
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cga: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">goikga/cga/cga.go (0.0%)</option>
				
				<option value="file1">goikga/examples/hexapod_leg/main.go (0.0%)</option>
				
				<option value="file2">goikga/pga/jacobian.go (0.0%)</option>
				
				<option value="file3">goikga/pga/motor.go (0.0%)</option>
				
				<option value="file4">goikga/pga/point.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cga

// This is a *parallel sketch* of a Conformal Geometric Algebra (CGA) API.
// It mirrors the PGA motor API in spirit but uses CGA-native entities
// (points as null vectors, rotors including translators, spheres/planes natively).
//
// A complete CGA engine is non-trivial; this file outlines the interface and provides
// minimal fallbacks using an internal dual-quaternion backend so you can wire code now
// and later swap for a full CGA core.
//
// Key ideas:
// - Points are represented as null-vectors P = x + 0.5 x^2 * e_inf + e_0
// - Rotors act by sandwich: X' = R X ~R
// - Translations are rotors in CGA (no special-casing), planes/spheres are native.
//
// For now, we alias to a tiny dual-quaternion backend to keep examples runnable.

import "goikga/pga"

type Rotor struct {
        M pga.Motor
}

type Vec3 = pga.Vec3

func Identity() Rotor                           <span class="cov0" title="0">{ return Rotor{M: pga.Identity()} }</span>
func FromAxisAngle(u Vec3, theta float64) Rotor <span class="cov0" title="0">{ return Rotor{M: pga.FromAxisAngle(u, theta)} }</span>
func Translator(t Vec3) Rotor                   <span class="cov0" title="0">{ return Rotor{M: pga.Translator(t)} }</span>
func Screw(p Vec3, u Vec3, theta float64, pitch float64) Rotor <span class="cov0" title="0">{
        return Rotor{M: pga.Screw(p, u, theta, pitch)}
}</span>

func (a Rotor) Mul(b Rotor) Rotor <span class="cov0" title="0">{ return Rotor{M: a.M.Mul(b.M)} }</span>
func (a Rotor) Inv() Rotor        <span class="cov0" title="0">{ return Rotor{M: a.M.Inv()} }</span>

func (a Rotor) ActPoint(p Vec3) Vec3 <span class="cov0" title="0">{ return a.M.ActPoint(p) }</span>
func (a Rotor) ActDir(v Vec3) Vec3   <span class="cov0" title="0">{ return a.M.ActDir(v) }</span>

// Notes for future full CGA:
// - Represent meet/join (∧, ∨) to project points onto planes/spheres.
// - Use inner product nullity to compute distances robustly.
// - Provide primitive constructors: Plane(n, d), Sphere(center, r), etc.
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "math"

        "goikga/pga"
)

func main() <span class="cov0" title="0">{
        // Example: 3-DoF leg FK using motors.
        // Hip at origin; axes:
        // L1: yaw about +Z, L2: pitch about +Y at hip-&gt;thigh joint, L3: pitch about +Y at knee.
        // Link lengths (example values):
        l1 := 0.05 // hip offset to thigh (m)
        l2 := 0.20 // thigh length
        l3 := 0.20 // shank length

        // Joint centers:
        hip := pga.V(0, 0, 0)
        thighJ := hip.Add(pga.V(l1, 0, 0))
        kneeJ := thighJ.Add(pga.V(l2, 0, 0))

        // Axes:
        z := pga.V(0, 0, 1)
        y := pga.V(0, 1, 0)

        // Angles:
        theta1 := 20 * math.Pi / 180
        theta2 := -10 * math.Pi / 180
        theta3 := 30 * math.Pi / 180

        // Build motor chain:
        M := pga.Identity().
                Mul(pga.Screw(hip, z, theta1, 0)).
                Mul(pga.Screw(thighJ, y, theta2, 0)).
                Mul(pga.Screw(kneeJ, y, theta3, 0)).
                Mul(pga.Translator(pga.V(l3, 0, 0))) // toe from knee along x

        // Toe in world:
        toe0 := pga.V(0, 0, 0) // relative toe origin before chain
        toe := M.ActPoint(toe0)
        fmt.Printf("Toe: %+v\n", toe)

        // Jacobian columns at current pose (linear velocity for each revolute joint)
        J1 := pga.RevoluteColumn(hip, z, toe)
        J2 := pga.RevoluteColumn(thighJ, y, toe)
        J3 := pga.RevoluteColumn(kneeJ, y, toe)
        fmt.Printf("Jacobian columns (linear part):\nJ1=%+v\nJ2=%+v\nJ3=%+v\n", J1, J2, J3)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package pga

// Minimal Jacobian helpers: Given a joint axis (through point c with direction u)
// and a toe point p, return the linear velocity column for an infinitesimal rotation dθ.
// v = ω × (p - c)  with ω = u (unit) and dθ absorbed later by the solver.
//
// For translations (prismatic), column is simply the axis direction.

func RevoluteColumn(axisPoint Vec3, axisDir Vec3, toe Vec3) Vec3 <span class="cov0" title="0">{
        u := axisDir.Normalized()
        r := toe.Sub(axisPoint)
        return u.Cross(r) // linear velocity direction per unit angular rate
}</span>

func PrismaticColumn(axisDir Vec3) Vec3 <span class="cov0" title="0">{
        return axisDir.Normalized()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package pga

// Motor implements rigid motions in SE(3) using a dual quaternion representation.
// This is practically equivalent to PGA motors for rigid motions and composes nicely.
// We expose only what we need: constructors for rotation/translation/screw, composition,
// action on points, and inversion.
//
// References:
// - Kavan et al., "Skinning with Dual Quaternions"
// - Dorst, "Geometric Algebra for Computer Science" (motors / bivector exponentials)

import "math"

// Quaternion: w + xi + yj + zk
type quat struct {
        w, x, y, z float64
}

func q(w, x, y, z float64) quat <span class="cov0" title="0">{ return quat{w, x, y, z} }</span>

func (a quat) Mul(b quat) quat <span class="cov0" title="0">{
        return quat{
                w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
                x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
                y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
                z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,
        }
}</span>

func (a quat) Conj() quat <span class="cov0" title="0">{ return quat{a.w, -a.x, -a.y, -a.z} }</span>

func (a quat) Norm() float64 <span class="cov0" title="0">{ return math.Sqrt(a.w*a.w + a.x*a.x + a.y*a.y + a.z*a.z) }</span>

func (a quat) Normalize() quat <span class="cov0" title="0">{
        n := a.Norm()
        if n == 0 </span><span class="cov0" title="0">{
                return q(1, 0, 0, 0)
        }</span>
        <span class="cov0" title="0">return q(a.w/n, a.x/n, a.y/n, a.z/n)</span>
}

func pure(v Vec3) quat <span class="cov0" title="0">{ return quat{0, v.X, v.Y, v.Z} }</span>

// Motor is a dual quaternion (r + ε d), where r is unit rotation, d encodes translation.
type Motor struct {
        r quat // real part (rotation)
        d quat // dual part
}

// Identity motor
func Identity() Motor <span class="cov0" title="0">{ return Motor{r: q(1, 0, 0, 0), d: q(0, 0, 0, 0)} }</span>

// FromAxisAngle creates a pure rotation about unit axis u by angle theta (radians).
func FromAxisAngle(u Vec3, theta float64) Motor <span class="cov0" title="0">{
        uhat := u.Normalized()
        half := 0.5 * theta
        s := math.Sin(half)
        r := q(math.Cos(half), uhat.X*s, uhat.Y*s, uhat.Z*s)
        return Motor{r: r, d: q(0, 0, 0, 0)}
}</span>

// Translator creates a pure translation by t (meters, or your units).
func Translator(t Vec3) Motor <span class="cov0" title="0">{
        // d = 0.5 * t * r  with r = 1 (no rotation), so d = 0.5 * pure(t).
        return Motor{r: q(1, 0, 0, 0), d: q(0, 0.5*t.X, 0.5*t.Y, 0.5*t.Z)}
}</span>

// Screw creates a rotation about axis u through point p, with angle theta and pitch h.
// Implementation: translate to axis, rotate, translate back plus pitch.
func Screw(p Vec3, u Vec3, theta float64, pitch float64) Motor <span class="cov0" title="0">{
        // Normalize axis
        u = u.Normalized()
        // Rotation about u
        R := FromAxisAngle(u, theta)

        // Translation along axis by h*theta (convention: pitch per radian)
        Tpitch := Translator(u.Scale(pitch * theta))

        // Conjugate by translation to rotate about a line through p:
        // M = T(p) * R * T(-p) * Tpitch
        Tp := Translator(p)
        Tm := Translator(p.Neg())
        return Tp.Mul(R).Mul(Tm).Mul(Tpitch)
}</span>

// Mul composes two motors: this followed by b.
func (a Motor) Mul(b Motor) Motor <span class="cov0" title="0">{
        // (r1 + ε d1)(r2 + ε d2) = r1 r2 + ε(r1 d2 + d1 r2)
        r := a.r.Mul(b.r)
        d := a.r.Mul(b.d)
        d = quat{d.w + a.d.Mul(b.r).w, d.x + a.d.Mul(b.r).x, d.y + a.d.Mul(b.r).y, d.z + a.d.Mul(b.r).z}
        return Motor{r: r, d: d}
}</span>

// Inv returns the inverse motor.
func (a Motor) Inv() Motor <span class="cov0" title="0">{
        rc := a.r.Conj()
        // For unit r: inverse is r* + ε(- r* d r*)
        dr := rc.Mul(a.d).Mul(rc)
        return Motor{r: rc, d: q(-dr.w, -dr.x, -dr.y, -dr.z)}
}</span>

// ActPoint applies the motor to a point p (as a Vec3).
func (a Motor) ActPoint(p Vec3) Vec3 <span class="cov0" title="0">{
        // Rotate
        rp := a.r.Mul(pure(p)).Mul(a.r.Conj())
        rot := Vec3{rp.x, rp.y, rp.z}
        // Translation vector t = 2 * (d * r_conj).vector
        tr := a.d.Mul(a.r.Conj())
        t := Vec3{2 * tr.x, 2 * tr.y, 2 * tr.z}
        return rot.Add(t)
}</span>

// ActDir applies only rotation to a direction vector.
func (a Motor) ActDir(v Vec3) Vec3 <span class="cov0" title="0">{
        rp := a.r.Mul(pure(v)).Mul(a.r.Conj())
        return Vec3{rp.x, rp.y, rp.z}
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package pga

import "math"

// Simple 3D vector for points/directions.
type Vec3 struct{ X, Y, Z float64 }

func V(x, y, z float64) Vec3 <span class="cov0" title="0">{ return Vec3{x, y, z} }</span>

func (a Vec3) Add(b Vec3) Vec3      <span class="cov0" title="0">{ return Vec3{a.X + b.X, a.Y + b.Y, a.Z + b.Z} }</span>
func (a Vec3) Sub(b Vec3) Vec3      <span class="cov0" title="0">{ return Vec3{a.X - b.X, a.Y - b.Y, a.Z - b.Z} }</span>
func (a Vec3) Scale(s float64) Vec3 <span class="cov0" title="0">{ return Vec3{s * a.X, s * a.Y, s * a.Z} }</span>

func (a Vec3) Dot(b Vec3) float64 <span class="cov0" title="0">{ return a.X*b.X + a.Y*b.Y + a.Z*b.Z }</span>
func (a Vec3) Cross(b Vec3) Vec3 <span class="cov0" title="0">{
        return Vec3{
                a.Y*b.Z - a.Z*b.Y,
                a.Z*b.X - a.X*b.Z,
                a.X*b.Y - a.Y*b.X,
        }
}</span>
func (a Vec3) Norm() float64 <span class="cov0" title="0">{ return math.Sqrt(a.Dot(a)) }</span>

func (a Vec3) Normalized() Vec3 <span class="cov0" title="0">{
        n := a.Norm()
        if n == 0 </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return a.Scale(1.0 / n)</span>
}
func (a Vec3) Neg() Vec3 <span class="cov0" title="0">{ return Vec3{-a.X, -a.Y, -a.Z} }</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
